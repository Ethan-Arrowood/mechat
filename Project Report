#Problem

To be able to use the MeChat app, a network application (with peer-to-peer architecture) that utilizes a TCP connection as well as 
sockets to communicate between users by implementing authentication, user-designated input for server selection, encryption, user 
account creation, log-in/log-out functionality, logging, communication between clients, sending and receiving past messages, listing
channels and users, and the ability to disconnect from the server.

#Design Workflow

With our MeChat app, we have a server set up in Javascript that communicates with the client program which is in Java.
Since TCP functionality can be implemented in any coding language, effectively the two programs should be able to coomunicate and the app 
should be able to run.

Steps:

-Instantiate socket
-Prompt for server details
-Attempt connection (try again if connection fails)
On Connection: 
-Say hello
-Prompt to authenticate
-new <username> <password> 
-if user already exists prompt to login instead
-else write auth details to data store and prompt user to login with new details
-login <username> <password> 
-if incorrect username or password send msg to user to try again
if correct: 
-check if username is already signed in 
-if true: prompt user to try a different account
-else create connection
-Prompt to pick a channel 
-connect <channel> 
-if channel name exists add user to it, allow user to begin chatting
-else, prompt to use list channels command to get list of available channels
Additional user controls:
-ability to logout (logout command)
-ability to disconnect from a channel or swap to another channel (connect and disconnect commands)
-ability to send and recieve past messages (chat and history commands)
-ability to list channels and users (list <users|channels> command)
Core functionality:
-User can connect to a chat server
-User can login to an account on the server
-User can send messages that are broadcasted to other users on the server
-User can logout from their account 
  a) Should keep user connected to server
-User can disconnect from the chat server 
  b) Auto-logout if still authenticated
Future Features (in no particular order or importance):
-Server can have multiple channels
-Users can connect to a server and then select a channel
-Users have a single login for all servers 
  a) Servers share an authentication database
-User client allows the user to select what server they want to connect to
-There is an admin client for having more control over the server
-Users can list all other users in a channel/server
-Messages are encrypted
-Users login with username and password
-Application has an UI 
  a) Mobile (React Native)
  b) Web (React)
  c) Desktop (Electron)
-Server's utilize multiprocessing and multithreading to support client connections or channels
-Server logs all traffic 
  a) messages are not logged; just the 'when/who' sent the message information
-Complete unit and integration testing

#Building Up To the Solution

Topics:

  I. The Application Layer:
    The MeChat app client intiates communication at the application level. Programs were written that utilize different end systems.
    In creating a network app, the client and server should be able to communicate over a network. Applications on end systems allows for rapid 
    app development and propagation. The Client program and Server programs run on different end systems. Still, they are able to 
    communicate over the network.
    Our app utilizes a peer-to-peer (P2P) architecture. There is no always-on server, arbitrary end systems directly communicate, and 
    peers request service from other peers and provide service in return to other peers. 
    Applications with P2P architectures have client processes (Client.java) & server processes (Server.js).
    In addition, in terms of the Application Layer, sockets process sends/receives messages to/from its socket. 
    To receive messages, a process  must have an identifier. A host device has a unique 32-bit IP address. The identifier includes both 
    IP address and port numbers associated with a process on a host.

  II. DNS:
    Included with the Application Layer is the Domain Name System protocol, which utilizes a distributed database implemented in 
    the hierarchy of many name servers. With this application-layer protocol, hosts and name servers communicate to resolve names 
    (address/name translation), in the case of MeChat the host is the computer running the Client program, and the name server is the 
    computer running the Server.js program. DNS is a core Internet function, which is implemented as an application-layer protocol and 
    made useful for our specific purposes. One of the actions performed by DNS services is the hostname to IP address translation.

  III. Socket Programming:
    The socket programming used in the MeChat app makes it possible for the application to open a connection via a socket by using 
    TCP (Transmission Control Protocol). TCP is a reliable, byte stream-oriented Transport Layer protocol, which is why we implemented
    lines of code that give stream functionality such as the following:
    
     BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in)); 
     
     ataOutputStream outToServer = new DataOutputStream( clientSocket.getOutputStream()); 
  
    With socket programming using TCP, our Client.java file must contact the server (Server.js), however the server process must first 
    be running.
    The server must have created a socket (door) that welcomes client’s contact. Thereafter the client contacts the server by:
    Creating a TCP socket, specifying the IP address and port number of the server process. In the chat application's case, the user 
    provides the IP address and port number of the desired server he/she wants to chat on, and the input is then read in to the 
    following statement:
    
    Socket clientSocket = new Socket(ip_address, port)
    
    When the client creates a socket: client TCP establishes connection to server TCP
  when contacted by client, server TCP creates new socket for server process to communicate with that particular client
  allows server to talk with multiple clients
  source port numbers used to distinguish clients (more in Chap 3)
  application viewpoint:
  TCP provides reliable, in-order
  byte-stream transfer (“pipe”) 
  between client and server

  
  IV. The Transport Layer
   provide logical communication between app processes running on different hosts
  transport protocols run in end systems 
  send side: breaks app messages into segments, passes to  network layer
  rcv side: reassembles segments into messages, passes to app layer
  more than one transport protocol available to apps
  Internet: TCP and UDP

  network layer: logical communication between hosts
 transpsort layer: logical communication between processes 
relies on, enhances, network layer services

  Internet transport-layer protocol
  reliable, in-order delivery (TCP)
congestion control 
flow control
connection setup
unreliable, unordered delivery: UDP
no-frills extension of “best-effort” IP
services not available: 
delay guarantees
bandwidth guarantees
  
  V. TCP
  
 Connection Management
 before exchanging data, sender/receiver “handshake”:
agree to establish connection (each knowing the other willing to establish connection)
agree on connection parameters

TCP: closing a connection
 client, server each close their side of connection
send TCP segment with FIN bit = 1
 respond to received FIN with ACK
on receiving FIN, ACK can be combined with own FIN
 simultaneous FIN exchanges can be handled

Fairness, parallel TCP connections
 application can open multiple parallel connections between two hosts
 web browsers do this 
 e.g., link of rate R with 9 existing connections:
new app asks for 1 TCP, gets rate R/10
new app asks for 11 TCPs, gets R/2 

  
  VI. The Network Layer
  
  transport segment from sending to receiving host 
on sending side encapsulates segments into datagrams
on receiving side, delivers segments to transport layer
network layer protocols in every host, router
router examines header fields in all IP datagrams passing through it

Two key network-layer functions
network-layer functions:
forwarding: move packets from router’s input to appropriate router output
routing: determine route taken by packets from source to destination
routing algorithms

Input port functions
physical layer:
bit-level reception
data link layer:
e.g., Ethernet
see chapter 5

Output ports
buffering required when datagrams arrive from fabric faster than the transmission rate
 scheduling discipline chooses among queued datagrams for transmission

  
  VII. IP
  
  IP protocol
 addressing conventions
 datagram format
 packet handling conventions
 
 IP addressing: introduction
 IP address: 32-bit identifier for host, router interface 
interface: connection between host/router and physical link
router’s typically have multiple interfaces
host typically has one or two interfaces (e.g., wired Ethernet, wireless 802.11)
IP addresses associated with each interface

Subnet Masks
Subnet masks, also call netmasks, are 32-bit numbers, like IP addresses
The first N bits are 1 and the remaining   32-N bits are 0
Written in dotted-decimal notation
Example: 255.255.0.0
The N tells you how many bits in the associated IP address are in the network address

Subnets
IP address: 
subnet part - high order bits
host part - low order bits 
what’s a subnet ?
device interfaces with same subnet part of IP address
can physically reach each other without intervening router

IP Addressing – The Subnet Mask
The network portion of the IP address assigned to all hosts on a network segment must be the same.
All hosts on a segment have the same subnet mask.

Types of Addresses
Host:The unique address assigned to each host in a network.


  
 #Implementation
  
  Tools:
  
    -Eclipse IDE
    -Java Programming Language
    -JavaScript Coding Language
    -Github Repository
    -host computer
    -server computer
    -Online Sources (See below:)
    
  #Instructions
  
    1.Run MeChat server on server computer
    2.Run MeChat client on host
    
    For client:
    3. Enter address information of desired server (IP, port number)
    4. When prompted, create username and password
    5. If user is already existing, enter credentials and log-in
    6. Once logged in, begin chat
    7. Client will encrypt message and send it to the server
    8. Server will decrypt and send key to designated user
    9. All messages between users will continue in similar fashion
    10. User may logout 
  
  #Demo Video
  
  
 
#Works Cited

https://www.youtube.com/watch?v=luUeSnIYjJo&t=166s

https://stackoverflow.com/questions/10924561/java-scanner-string-input-if-statement-not-working

https://crunchify.com/how-to-get-server-ip-address-and-hostname-in-java/

https://stackoverflow.com/questions/43194442/how-do-i-take-user-input-and-pass-it-into-a-constructor-in-java-it-says-that-ar
