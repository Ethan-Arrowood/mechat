#Problem

To be able to use the MeChat app, a network application (with peer-to-peer architecture) that utilizes a TCP connection as well as 
sockets to communicate between users by implementing authentication, user-designated input for server selection, encryption, user 
account creation, log-in/log-out functionality, logging, communication between clients, sending and receiving past messages, listing
channels and users, and the ability to disconnect from the server.

#Design Workflow

With our MeChat app, we have a server set up in Javascript that communicates with the client program which is in Java.
Since TCP functionality can be implemented in any coding language, effectively the two programs should be able to coomunicate and the app 
should be able to run.

Steps:

Instantiate socket
Prompt for server details
Attempt connection (try again if connection fails)
On Connection: 
Say hello
Prompt to authenticate
new <username> <password> 
if user already exists prompt 
to login instead
else write auth details to data store and prompt user to login with new details
login <username> <password> 
if incorrect username or password send msg to user to try again
if correct: 
check if username is already signed in 
if true: prompt user to try a different account
else create connection
Prompt to pick a channel 
connect <channel> 
if channel name exists add user to it, allow user to begin chatting
else, prompt to use list channels command to get list of available channels
Additional user controls:
ability to logout (logout command)
ability to disconnect from a channel or swap to another channel (connect and disconnect commands)
ability to send and recieve past messages (chat and history commands)
ability to list channels and users (list <users|channels> command)
Core functionality:
User can connect to a chat server
User can login to an account on the server
User can send messages that are broadcasted to other users on the server
Use can logout from their account 
Should keep user connected to server
Use can disconnect from the chat server 
Auto-logout if still authenticated
Future Features (in no particular order or importance):
Server can have multiple channels
Users can connect to a server and then select a channel
Users have a single login for all servers 
Servers share an authentication database
User client allows the user to select what server they want to connect to
There is an admin client for having more control over the server
Users can list all other users in a channel/server
Messages are encrypted
Users login with username and password
Application has an UI 
Mobile (React Native)
Web (React)
Desktop (Electron)
Server's utilize multiprocessing and multithreading to support client connections or channels
Server logs all traffic 
messages are not logged; just the 'when/who' sent the message information
Complete unit and integration testing

#Building Up To the Solution

Topics:

  I. The Application Layer:
    The MeChat app client intiates communication at the application level. Programs were written that utilize different end systems.
    In creating a network app, the client and server should be able to communicate over a network. Applications on end systems allows for rapid 
    app development and propagation. The Client program and Server programs run on different end systems. Still, they are able to 
    communicate over the network.
    Our app utilizes a peer-to-peer (P2P) architecture. There is no always-on server, arbitrary end systems directly communicate, and 
    peers request service from other peers and provide service in return to other peers. 
    Applications with P2P architectures have client processes (Client.java) & server processes (Server.js).
    In addition, in terms of the Application Layer, ockets
process sends/receives messages to/from its socket
socket analogous to door
sending process shoves message out door
sending process relies on transport infrastructure on other side of door to deliver message to socket at receiving process

Addressing processes
to receive messages, process  must have identifier
host device has unique 32-bit IP address
identifier includes both IP address and port numbers associated with process on host.






  II. DNS:
  
  Domain Name System:
distributed database implemented in hierarchy of many name servers
application-layer protocol: hosts, name servers communicate to resolve names (address/name translation)
note: core Internet function, implemented as application-layer protocol
complexity at network’s “edge”

DNS services
hostname to IP address translation

authoritative DNS servers: 
organization’s own DNS server(s), providing authoritative hostname to IP mappings for organization’s named hosts 
can be maintained by organization or service provider

Local DNS name server

does not strictly belong to hierarchy
each ISP (residential ISP, company, university) has one
also called “default name server”
when host makes DNS query, query is sent to its local DNS server
has local cache of recent name-to-address translation pairs (but may be out of date!)
acts as proxy, forwards query into hierarchy
  
 // III. Web and HTTP //
 
  III. Socket Programming:
  
  TCP: reliable, byte stream-oriented 
  
Application Example:
client reads a line of characters (data) from its keyboard and sends data to server
server receives the data and converts characters to uppercase
server sends modified data to client
client receives modified data and displays line on its screen

Socket programming with TCP
client must contact server
server process must first be running
server must have created socket (door) that welcomes client’s contact
client contacts server by:
Creating TCP socket, specifying IP address, port number of server process
when client creates socket: client TCP establishes connection to server TCP
when contacted by client, server TCP creates new socket for server process to communicate with that particular client
allows server to talk with multiple clients
source port numbers used to distinguish clients (more in Chap 3)
application viewpoint:
TCP provides reliable, in-order
byte-stream transfer (“pipe”) 
between client and server

  
  IV. The Transport Layer
   provide logical communication between app processes running on different hosts
 transport protocols run in end systems 
send side: breaks app messages into segments, passes to  network layer
rcv side: reassembles segments into messages, passes to app layer
 more than one transport protocol available to apps
Internet: TCP and UDP

  network layer: logical communication between hosts
 transpsort layer: logical communication between processes 
relies on, enhances, network layer services

  Internet transport-layer protocol
  reliable, in-order delivery (TCP)
congestion control 
flow control
connection setup
unreliable, unordered delivery: UDP
no-frills extension of “best-effort” IP
services not available: 
delay guarantees
bandwidth guarantees
  
  V. TCP
  
 Connection Management
 before exchanging data, sender/receiver “handshake”:
agree to establish connection (each knowing the other willing to establish connection)
agree on connection parameters

TCP: closing a connection
 client, server each close their side of connection
send TCP segment with FIN bit = 1
 respond to received FIN with ACK
on receiving FIN, ACK can be combined with own FIN
 simultaneous FIN exchanges can be handled

Fairness, parallel TCP connections
 application can open multiple parallel connections between two hosts
 web browsers do this 
 e.g., link of rate R with 9 existing connections:
new app asks for 1 TCP, gets rate R/10
new app asks for 11 TCPs, gets R/2 

  
  VI. The Network Layer
  
  transport segment from sending to receiving host 
on sending side encapsulates segments into datagrams
on receiving side, delivers segments to transport layer
network layer protocols in every host, router
router examines header fields in all IP datagrams passing through it

Two key network-layer functions
network-layer functions:
forwarding: move packets from router’s input to appropriate router output
routing: determine route taken by packets from source to destination
routing algorithms

Input port functions
physical layer:
bit-level reception
data link layer:
e.g., Ethernet
see chapter 5

Output ports
buffering required when datagrams arrive from fabric faster than the transmission rate
 scheduling discipline chooses among queued datagrams for transmission

  
  VII. IP
  
  IP protocol
 addressing conventions
 datagram format
 packet handling conventions
 
 IP addressing: introduction
 IP address: 32-bit identifier for host, router interface 
interface: connection between host/router and physical link
router’s typically have multiple interfaces
host typically has one or two interfaces (e.g., wired Ethernet, wireless 802.11)
IP addresses associated with each interface

Subnet Masks
Subnet masks, also call netmasks, are 32-bit numbers, like IP addresses
The first N bits are 1 and the remaining   32-N bits are 0
Written in dotted-decimal notation
Example: 255.255.0.0
The N tells you how many bits in the associated IP address are in the network address

Subnets
IP address: 
subnet part - high order bits
host part - low order bits 
what’s a subnet ?
device interfaces with same subnet part of IP address
can physically reach each other without intervening router

IP Addressing – The Subnet Mask
The network portion of the IP address assigned to all hosts on a network segment must be the same.
All hosts on a segment have the same subnet mask.

Types of Addresses
Host:The unique address assigned to each host in a network.


  
 #Implementation
  
  Tools:
  
    -Eclipse IDE
    -Java Programming Language
    -JavaScript Coding Language
    -Github Repository
    -host computer
    -server computer
    -Online Sources (See below:)
    
  #Instructions
  
    1.Run MeChat server on server computer
    2.Run MeChat client on host
    
    For client:
    3. Enter address information of desired server (IP, port number)
    4. When prompted, create username and password
    5. If user is already existing, enter credentials and log-in
    6. Once logged in, begin chat
    7. Client will encrypt message and send it to the server
    8. Server will decrypt and send key to designated user
    9. All messages between users will continue in similar fashion
    10. User may logout 
  
  #Demo Video
  
  
 
#Works Cited

https://www.youtube.com/watch?v=luUeSnIYjJo&t=166s

https://stackoverflow.com/questions/10924561/java-scanner-string-input-if-statement-not-working

https://crunchify.com/how-to-get-server-ip-address-and-hostname-in-java/

https://stackoverflow.com/questions/43194442/how-do-i-take-user-input-and-pass-it-into-a-constructor-in-java-it-says-that-ar
